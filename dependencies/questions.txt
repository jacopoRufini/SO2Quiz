Quale delle seguenti affermazioni sui processi Linux è falsa?
 In un determinato istante, non possono esserci 2 processi distinti con lo stesso PID
 Per creare i PID dei processi si usano dei numeri interi che crescono sempre
 In istanti diversi, possono esserci 2 processi distinti con lo stesso PID
 Ogni processo può conoscere il suo PID
b

Quale delle seguenti affermazioni sui processi Linux è vera?
 Normalmente, il processo figlio, una volta terminata la sua computazione, attende, con una chiamata alla syscall wait, che il padre termini e gli restituisca il suo exit status
 Un processo diventa zombie se termina prima di almeno uno dei processi che abbia eventualmente creato
 Ogni processo può conoscere il proprio PID, ma non quello del processo che l’ha creato
 Con l’eccezione del primo processo, tutti i processi sono creati con una fork effettuata da un altro processo in esecuzione
d

Quale delle seguenti affermazioni sui processi Linux è falsa?
 Digitare un comando sulla shell genera sempre un nuovo processo
 Esistono file che non possono essere eseguiti per diventare processi
 Affinchè un file possa diventare un processo è necessario che abbia i permessi di esecuzione
 Qualsiasi computazione eseguita dal sistema operativo è contenuta dentro un qualche processo
a

Quale delle seguenti affermazioni sui processi Linux è vera?
 Eseguendo k volte un file eseguibile, si generano k diversi processi
 Per poter lanciare un file eseguibile, è prima necessario aspettare che il comando precedente sia terminato
 Tutti i processi sono sempre in stato di RUNNING
 Un processo è sempre un’istanza di uno script bash
a

Un programma scritto in linguaggio C:
 Rappresenta le stringhe ESCLUSIVAMENTE come array di caratteri terminate dal carattere ‘\n’
 Rappresenta le stringhe ESCLUSIVAMENTE come array di caratteri terminate dal carattere ‘^M’
 Rappresenta le stringhe ESCLUSIVAMENTE come array di caratteri terminate dal carattere ‘0’
 Rappresenta le stringhe come array di caratteri terminate dal carattere ‘\0’
d

Quale delle seguenti affermazioni è vera?
 Linus Torvalds ha riscritto i pacchetti di Unix, creando i pacchetti GNU
 Tutte le opzioni sono false
 Linus Torvalds ha scritto il primo kernel di Linux all’inizio degli anni ‘80
 Richard Stallman ha descritto per primo la licenza GPL
d

Quale delle seguenti affermazioni è vera?
 Nessuna delle opzioni è vera
 È possibile montare un filesystem solo se è dichiarato nel file /etc/fstab
 È possibile montare un filesystem solo se è dichiarato nel file /etc/mtab
 Ad ogni filesystem corrisponde un disco fisico o parte di esso(partizione)
a

Quale delle seguenti affermazioni sulla comunicazione tra processi in Linux è vera?
 Per far comunicare qualunque coppia di processi è necessario metterli in pipeling da shell
 Usando la syscall pipe, è possibile far comunicare qualunque coppia di processi
 Nessuna delle opzioni è vera
 Usando le named pipes, è possibile far comunicare solo processi parenti(ad es., padre con figlio)
c

Si supponga di avere il seguente frammento di codice: FILE *stream = fopen(NOMEFILE, “w”); Dire quale frammento di codice ha lo stesso effetto.
 int fd = open(NOMEFILE, O_WRONLY | O_CREAT, 0666);
 int fd = open(NOMEFILE, O_WRONLY | O_TRUNC);
 int fd = open(NOMEFILE, O_WRONLY);
 int fd = open(NOMEFILE, O_WRONLY | O_CREAT | O_TRUNC, 0666);
d

Quale delle seguenti affermazioni sulle syscall di Linux che riguardano i files è falsa?
 Chiamando la syscall select, è possibile monitorare un insieme di file descriptor, ed essere notificati non appena ce n’è uno che è diventato disponibile per un’operazione di lettura o scrittura
 Per richiedere un lock su un file (o su una porzione di esso), occorre chiamare la syscall ioctl
 È possibile usare la syscall select sia in modo bloccante che in modo non bloccante
 Le syscall ioctl e fcntl ammettono 2 o 3 argomenti, a seconda dell’operazione richiesta
b

Quale delle seguenti affermazioni sui segnali Linux è vera?
 Tutti i segnali, se non opportunamente catturati, provocano la terminazione del processo, con l’eccezione del segnale STOP
 Per un processo è sempre possibile ridefinire il comportamento di un qualsiasi segnale
 È possibile per un qualunque processo inviare un segnale ad un qualsiasi altro processo dello stesso utente
 Nessuna delle altre affermazioni è vera
c

Quale delle seguenti affermazioni sugli errori delle syscall di Linux è vera?
 Per stampare su stderr la spiegazione di un errore verificatosi in una syscall, il cui nome sia contenuto nella variabile syscall_name (di tipo char *), si può effettuare la seguente chiamata: perror(“Si è verificato il seguente errore nella chiamata a %s”, syscall_name);
 Per stampare su stdout la spiegazione di un errore verificatosi in una syscall si può effettuare la seguente chiamata: prinf(“%s\n”, stderror(errno));
 Per stampare su stdout la spiegazione di un errore verificatosi in una syscall è sufficiente chiamare perror
 Per stampare su stdout la spiegazione di un errore verificatosi in una syscall è necessario scrivere uno switch sulla variabile globale errno
b

La stringa Informatica9000 ha un match con la seguente REGEX:
 Informatica9000$
 ^Informatica900$
 Informatica9[0^3]
 [^IKU]nformatica
a

Quali delle seguenti affermazioni sui comandi della bash è vera?
 Il comando cat stringa può essere usato per scrivere una stringa su stdout
 Eseguendo il comando echo ‘date’ viene stampata la data e l’ora corrente (secondo l’orologio di sistema)
 Il comando man cmd restituisce in sequenza tutte le pagine di manuale per il comando cmd contenute nelle varie sezioni del manuale
 Il comando clear può essere usato per pulire completamente lo schermo: dopo l’esecuzione, il terminale non conterrà alcuna scritta
b

Relativamente alla programmazione bash, la variabile IFS:
 Nessuna delle opzioni è vera
 È l’acronimo di Internal Field Splitting
 Rappresenta una variabile contenente la sequenza di tutti i caratteri utilizzati per la separazione in parole (word splitting)
 Rappresenta il carattere utilizzato per la separazione in parole (word splitting)
c

Il linguaggio C:
 Richiede che i programmi siano sempre scritti in file con estensione .c
 Nasce per risolvere le ambiguità e i problemi di portabilità su architetture diverse di cui soffrono gli altri linguaggi di programmazione finora noti
 È stato definito come linguaggio Open Source da Dennis Ritchie
 È stato definito presso i laboratori di ricerca di una compagnia telefonica americana
d

Quale delle seguenti affermazioni sulle funzioni malloc, calloc, realloc e free è falsa?
 Le due chiamate calloc(N, sizeof(int)) e realloc(NULL, N*sizeof(int)) hanno sempre lo stesso effetto
 Le due chiamate malloc(N*sizeof(int)) e realloc(NULL, N*sizeof(int)) hanno sempre lo stesso effetto
 Il primo argomento di realloc, quando non NULL, deve contenere il risultato di una precedente chiamata a malloc, calloc o realloc
 I risultati di malloc, calloc e realloc possono essere passati alla funzione free per poter essere riallocati da future malloc, calloc e/o realloc
a

Quale dei seguenti sistemi operativi non è un antenato di Linux?
 Unix
 Le altre risposte contengono tutte degli antenati di Linux
 MacOSX
 MULTICS
c

Si consideri il comando: find Doc* \( -name ‘Doc*’ -a -type d \) -o -newer Documenti -exec touch ‘{}’ \;
 Nessuna delle altre opzioni è vera
 L’azione non è specificata correttamente, quindi la bash restituirà un messaggio d’errore
 Il comando stampa su schermo tutte le directory il cui nome comincia con Doc e che siano state modificate più recentemente della directory Documenti
 Il comando modifica tutti i tempi(atime, mtime e ctime) di tutte le directory il cui nome comincia con Doc e che siano state modificate più recentemente dalla directory Documenti
a

Quale delle seguenti affermazioni sulla syscall fork è falsa?
 Ritorna 2 valori diversi a seconda che si tratti del processo padre o del processo figlio
 Genera una copia esatta del processo chiamante, con alcune eccezioni; tra queste ultime vi è lo stack delle chiamate
 Genera una copia esatta del processo chiamante, con alcune eccezioni; tra queste ultime vi è il PID
 Genera una copia esatta del processo chiamante, con alcune eccezioni; tra queste ultime vi è il PPID
b

Quale delle seguenti affermazioni sui comando cmp, diff e patch è vera?
 L’opzione -b ha lo stesso significato sia per diff che per cmp
 È possibile usare il comando patch solo se si ha l’output del comando diff
 È possibile usare il comando patch solo se si ha, indifferentemente, l’output del comando diff o del comando cmp
 L’opzione -i di cmp permette di considerare come uguali le differenze sul solo minuscolo/maiuscolo
b

Si supponga di voler avere in esecuzione in background i comando cmd1 e cmd2. Quale dei seguenti modi è corretto?
 cmd1 #premere Ctrl+Z bg cmd2 #premere Ctrl+Z bg
 cmd1 #premere Ctrl+Z fg cmd2 #premere Ctrl+Z fg
 cmd1 #premere Ctrl+Z bg cmd2 #premere Ctrl+Z
 cmd1 #premere Ctrl+Z cmd2 #premere Ctrl+Z fg
a

Quale delle seguenti affermazioni sulle syscall di Linux che riguardano i files è falsa?
 La syscall link(oldpath, newpath) ha lo stesso effetto del comando bash ln oldpath newpath
 La syscall unlink(nomefile) ha lo stesso effetto del comando bash rm nomefile
 La syscall unlink(nomefile) rimuove sempre il contenuto di nomefile dal disco, se nomefile è un file regolare
 La syscall symlink(oldpath, newpath) ha lo stesso effetto del comando bash ln -s oldpath newpath
c

Quale delle seguenti affermazioni sui processi Linux è vera?
 Nessuna delle altre opzioni è vera
 Ciascun job è composto al massimo da un processo
 Per vedere i jobs in foreground, è sufficiente usare il comando jobs
 Quando un processo in foreground termina, la bash stampa il job id del processo e la ragione della terminazione
a

Quale delle seguenti affermazioni sulla syscall sigaction è vera?
 Nessuna delle altre opzioni è vera
 Permette di definire una funzione che viene eseguita qualsiasi segnale arrivi al processo
 Chiamandola ripetutamente, e passandole al primo argomento via via tutti i segnali disponibili, è possibile definire una funzione che viene eseguita qualsiasi segnale arrivi al processo
 Permette di definire quali segnali vanno ignorati finché l’handler del segnale è in esecuzione
a

Quale delle seguenti affermazioni sulla syscall sigaction è vera?
 Nessuna delle altre opzioni è vera
 Permette di definire una funzione che viene eseguita qualsiasi segnale arrivi al processo
 Chiamandola ripetutamente, e passandole al primo argomento via via tutti i segnali disponibili, è possibile definire una funzione che viene eseguita qualsiasi segnale arrivi al processo
 Permette tramite il campo sa_mask della struttura struct sigaction, di definire quali segnali vanno ignorati finché l’handler del segnale è in esecuzione
a

Si supponga di voler lanciare in background i comandi cmd1 e cmd2. Quale dei seguenti modi è corretto?
 Nessuna delle altre opzioni è corretta
 cmd1 & cmd2
 ( cmd1; cmd2 ) &
 cmd1; cmd2 &
 a

Quale delle seguenti affermazioni sul comando time è falsa?
 Il comando /usr/bin/time cmd ha anche l’effetto di eseguire il comando cmd
 Il comando /usr/bin/time cmd può solo mostrare il tempo (di CPU, di sistema e reale)
 Esistono 2 comandi time: uno è una keyword della bash e l’latro corrisponde ad un file eseguibile (solitamente /usr/bin/time)
 Il comando time cmd, eseguito dalla bash, può solo mostrare il tempo (di CPU, di sistema e reale)
b

Quale delle seguenti affermazioni sui comandi less e more è falsa?
 Sono specialmente utili quando si vuole visualizzare un output molto lungo (che non è possibile visualizzare in un’intera schermata di terminale
 Entrambi permettono di ricercare espressioni regolari
 Per terminarli occorre premere CTRL+C
 Sono entrambi interattivi
c

Quale delle seguenti affermazioni sulle syscall wait e waitpid è falsa?
 Se una chiamata wait(&status); ha successo, il valore di status coincide con l’exit status del processo figlio appena terminato
 Ogni chiamata wait(&status); è equivalente alla chiamata waitpid(-1, &status, 0)
 Le chiamate alla wait sono sempre bloccanti
 Le chiamate alla waitpid possono non essere bloccanti
a

Relativamente alla programmazione bash, quale delle seguenti affermazioni è vera?
 L’acronimo BASH sta per Bourne Advanced Shell
 Nessuna delle altre opzioni è vera
 È possibile definire array associativi, con la seguente sintassi: declare -A myArray={‘key1’=’value1’, ‘key2’=’value2’}
 Non è possibile definire array associativi
b

Una directory di un filesystem:
 Può contenere solo file regolari e altre directory
 Non può mai contenere degli hard disk
 Nessuna delle opzioni è vera
 Ha sempre una directory padre, eventualmente corrisponde a se stessa
d

Quale delle seguenti affermazioni sulle syscall di Linux che riguardano i files è falsa?
 La syscall chdir ha l’effetto di cambiare l’esecuzione delle sole chiamate ad open che usano path relativi come primo argomento
 La syscall chdir(path) ha lo stesso effetto del comando bash cd path lanciato in una sottoshell
 La syscall rename(oldpath, newpath) ha lo stesso effetto del comando bash cp oldpath newpath
 La syscall chroot ha l’effetto di cambiare l’esecuzione delle sole chiamate ad open che usano path assoluti come primo argomento
c

Quale delle seguenti affermazioni sulle syscall di Linux che riguardano i files e che si trovano nella sezione 2 del manuale è falsa?
 Mentre le funzioni della libreria standard possono solo agire solo su file regolari, le syscall di Linux possono agire su tutti i tipi di file(regolari, directory, pipe, …)
 Le funzioni della libreria standard agiscono su una struttura di tipo FILE *, mentre le syscall agiscono su un file descriptor interno
 Nessuna delle syscall di Linux accetta come argomento input o output formattato stile printf
 Le syscall Linux permettono solamente le seguenti operazioni: apertura, chiusura, scrittura, lettura, posizionamento
d

Quale delle seguenti affermazioni sulle syscall di Linux che riguardano le directory è falsa?
 La syscall readdir, con argomento uguale a quanto ritornato da una precedente opendir avvenuta con successo, ritorna un puntatore ad una struttura struct dirent, che contiene il nome di un file o di una directory contenuta nella directory passata a opendir
 Chiamare la syscall open su una directory può avere successo
 Per poter cambiare il contenuto di una directory occorre aprirla con la syscall opendir
 Per poter leggere il contenuto di una directory occorre aprirla con la syscall opendir
c

Quale delle seguenti affermazioni sul comando kill è falsa?
 Per mandare il segnale 9 al processo in background con job id 3, è sufficiente scrivere il comando kill -KILL %3
 Per mandare il segnale SIGTERM al processo con PID 19330, è sufficiente scrivere il comando kill -SIGTERM 19330
 Per mandare il segnale SIGINT al processo in background con job id 3, è sufficiente scrivere il comando kill –‘kill -l SIGINT’ %3
 Per mandare il segnale 9 al processo con PID 10, è sufficiente scrivere il comando kill -KILL %10
d

Per eliminare tutte le linee duplicate in un file di testo (senza preoccuparsi dell’ordinamento delle righe) occorre:
 utilizzare congiuntamente i comandi sort e uniq
 utilizzare congiuntamente i comandi cat e grep
 utilizzare il comando uniq con opzione -u
 utilizzare il comando uniq
a

Quale delle seguenti affermazioni sulle pipe di Linux è vera?
 Usando la syscall pipe, vengono automaticamente aperti 2 file descriptor
 Nessuna delle altre opzioni è vera
 Per usare le named pipes, è sempre necessario chiamare la syscall mkfifo
 usando la syscall mkfifo, viene aperto un solo file descriptor
a

Quale delle seguenti affermazioni sulle syscall di Linux che riguardano i files è falsa?
 La syscall chown(nomefile, -1, gid) ha lo stesso effetto del comando bash chgrp nomefile
 La syscall mkdir(nomedir, mode) ha lo stesso effetto del comando bash mkdir -m mode nomedir
 La syscall dup2(2, 1) ha l’effetto di ridigere lo stdout nello stderr
 La syscall stat(nomefile, buf) ha lo stesso effetto del comando bash stat nomefile
d

Gli script sed:
 Sono file di testo composti da sequenze di linee che possono essere del tipo N azione, dove N è il numero di linea del file di ingresso che sed sta processando ed azione è un comando Unix da eseguire sulla linea N
 Nessuna delle altre opzioni è vera
 Sono script (es: bash) al cui interno viene allocato il comando sed
 Sono file di testo composti da sequenze di linee del tipo condizione azione, dove la condizione può essere, ad esempio, un numero di linea o una espressione regolare
d

Quale delle seguenti affermazioni sui comandi cat e od è falsa?
 I comandi od file e cat file non possono mai dare lo stesso risultato
 I comandi od file e cat file danno lo stesso risultato se file è un file di testo ASCII
 Il comando cat interpreta ogni sequenza di byte letta come un carattere (tipicamente UTF8), e lo stampa
 Il comando od scrive ogni singolo byte letto usando il suo valore numerico
b

Relativamente alla programmazione bash, quale delle seguenti affermazioni sul carattere # è vera?
 Rappresenta sempre l’inizio di un commento, con un’unica eccezione: quando è preceduto dal carattere $
 Se è seguito dal carattere !, non rappresenta mai l’inizio di un commento
 Nessula delle opzioni è vera
 Se presente in uno script, tutto quello che lo segue è sempre considerato commento
c

Quale delle seguenti affermazioni sulle syscall dei processi Linux è falsa?
 La syscall setuid() permette a qualsiasi processo di cambiare il suo real user ID
 La syscall getuid() permette a qualsiasi processo di conoscere il suo real user ID
 La syscall getppid() ritorna il PID del processo che ha generato quello chiamante (o che lo ha adottato)
 La syscall getpid() ritorna il PID del processo chiamante
a

Relativamente alla programmazione bash, quale delle seguenti affermazioni è vera?
 Si può dichiarare esplicitamente il tipo di una variabile, anteponendolo al nome della variabile stessa (es: int count)
 Ad una variabile di tipo intero non è possibile assegnare un valore di tipo diverso, altrimenti il programma termina con un errore
 Nessuna delle altre opzioni è vera
 Non è possibile dichiarare una variabile in sola lettura: una variabile definita in uno script bash è sempre modificabile
c

Relativamente alla programmazione bash, quale delle seguenti affermazioni è vera?
 Si può dichiarare esplicitamente il tipo di una variabile, anteponendolo al nome della variabile stessa (es: int count)
 Ad una variabile di tipo intero non è possibile assegnare un valore di tipo diverso, altrimenti il programma termina con un errore
 Una volta dichiarato il tipo di una variabile, lo si può cambiare solo dopo aver invocato il comando unset
 Non è possibile dichiarare una variabile in sola lettura: una variabile definita in uno script bash è sempre modificabile
c

Quale delle seguenti affermazioni sul comando ps è vera?
 Senza nessun argomento, mostra tutti i processi lanciati dall’utente attuale nel terminale attuale
 Per ogni processo, mostra sempre il suo PID, indipendentemente dagli argomenti con cui viene lanciato
 Non è possibile usarlo per vedere i processi lanciati dall’utente root
 È possibile usarlo per vedere solo i processi che superano un certo uso della RAM
a

Quale delle seguenti affermazioni sui processi Linux è vera?
 Nessuna delle altre opzioni è vera
 Per ogni terminale aperto, ci può essere al massimo un job in background
 Per lanciare un processo in modo tale che non scriva su stdout, lasciando così modo di scrivere altri comandi sulla bash, è sufficiente lanciarlo in background
 Se si vuole dare input da stdin senza redirezioni ad un processo, è necessario lanciarlo in foreground
d

Quale delle seguenti affermazioni sui processi Linux è vera?
 Nessuna delle altre opzioni è vera
 Il text segment contiene le istruzioni da eseguire, e non può essere condiviso con altri processi
 Lo stack contiene i dati statici inizializzati ed alcune costanti d’ambiente
 Il processo control block (PCB) mantiene le informazioni essenziali di ogni processo, e uno stesso PCB può essere condiviso tra processi diversi
a

Quale delle seguenti affermazioni sui processi Linux è falsa?
 I comandi builtin della bash generano sempre nuovi processi
 Per capire se un comando della bash è o no builtin, è sufficiente usare il comando type
 Il comando cd è builtin della bash
 Un comando builtin della bash non corrisponde ad alcun file eseguibile dedicato
a

Quale dei seguenti campi non è presente nel process control block?
 Change time
 GID reale ed effettivo
 Nice
 Current working directory
a

Quale delle seguenti affermazioni sui comandi della bash è falsa?
 Il comando type file mostra il tipo del file (regolare, directory, etc)
 Il comando whoami mostra lo username dell’utente attualmente loggato nel terminale in cui viene digitato il comando (potrebbe non coincidere con l’utente che ha effettuato il login grafico)
 Il comando id può essere usato per visualizzare i gruppi cui un utente appartiene
 Il comando which cmd mostra qual è il file eseguibile che viene eseguito quando si lancia il comando cmd, ma solo per i comando che non sono builtin
a

Quale delle seguenti affermazioni sulle syscall dei processi in Linux è vera?
 Se un processo viene lanciato nel seguente modo: var=valore ./a.out, allora esso può ottenere var con la chiamata a getenv(“valore”);
 Per qualsiasi processo è possibile conoscere il suo ambiente di esecuzione senza effettuare alcuna syscall
 Se un processo viene lanciato nel seguente modo: var=valore ./a.out, allora esso può ottenere valore con la chiamata a setenv(“var”,”valore”, 1);
 Se un processo viene lanciato nel seguente modo: var=valore ./a.out, allora esso può ottenere valore con la chiamata a putenv(“var=valore”);
b

Quale delle seguenti affermazioni è vera?
 Linux è multiutente, perché definisce più utenti, di cui però uno solo può essere loggato su una data macchina
 Linux è multiutente, perché permette a più utenti contemporaneamente di essere loggati sulla stessa macchina
 Linux è multiprocesso, perché permette a più utenti contemporaneamente di essere loggati sulla stessa macchina
 Linux è multiprocesso, perché puù essere usato su una macchina con più processi
b

Il linguaggio C:
 È incompatibile con i Sistemi Operativi della famiglia Windows
 Nessuna delle altre opzioni è vera
 È un linguaggio strutturato e compilato
 E un linguaggio non strutturato e compilato
c

Quale delle seguenti non è un possibile stato di un processo Linux?
 Uninterruptible sleep
 Stopped
 Running
 Continued
d

Quale delle seguenti affermazioni sul comando top è vera?
 Se lanciato con il comando top, per terminarlo è necessario premere CTRL+C
 Il suo output è uguale a quello di ps, ma le opzioni sono diverse
 Se lanciato con il comando top b, per terminarlo è sufficiente premere il tasto Q
 Nessuna delle altre affermazioni è vera
d

Relativamente alla programmazione bash, quali delle seguenti affermazioni è esatta?
 Il comando $count[3] stampa il quarto elemento dell’array count
 Il comando $count[3] stampa l’elemento con indice 3 dell’array count. Gli array in bash sono sparsi quindi non c’è garanzia che si tratti del terzo o del quarto elemento dell’array
 Il comando $count[3] stampa il terzo elemento dell’array count
 Nessuna delle opzioni
d

Quale delle seguenti affermazioni sui processi Linux è vera?
 Per visualizzare i processi attualmente in esecuzione su una determinata bash, è sufficiente usare il comando jobs
 Tutti i processi in background sono in stato Stopped
 Per riportare in foreground un determinato job in background, è sufficiente dare il comando fg sulla bash dove il job è in background, ma solo se tale job è l’attuale “current job” in background
 Per stoppare un processo in foreground, si può sia mandare un segnale SIGTSTP che premere CTRL+Z in una qualsiasi shell
c

Per modificare tutte le occorrenze della lettera o ed i rispettivamente in O ed 1 di un file di testo, quale comando è più appropriato utilizzare?
 awk
 sed
 grep
 tr
b

Si supponga di voler vedere, per tutti i processi dell’utente utente, il suo PID, il suo PPID, il comando usato per lanciare il processo (con tutti gli argomenti), la sua occupazione totale di memoria in kB e la sua attuale occupazione di memoria in RAM (senza considerare quindi la parte eventualmente swappata su disco), sempre in kB. Quale dei seguenti comandi è quello corretto?
 ps -uutente -o pid,ppid,cmd,rss,vsz
 ps -uutente -o pid,ppid,cmd,rss,sz
 ps -e -o pid,ppid,cmd,vsz,rss
 ps -uutente -o pid,ppid,cmd,vsz,rss
d

Una espressione regolare:
 È composta da caratteri literal e caratteri di punteggiatura
 Non può essere formata da soli caratteri non literal
 Descrive implicitamente un insieme di stringhe che hanno almeno un match con se stessa
 Non può essere formata da soli caratteri literal
c

Quale delle seguenti affermazioni è vera?
 Ogni risorsa di un sistema Unix, ad eccezione dei processi e periferiche hardware, è rappresentato da un file
 Ogni risorsa di un sistema Unix, ad eccezione delle connessioni di rete (socket), è rappresentato da un file
 Ogni risorsa di un sistema Unix, ad eccezione dei processi, è rappresentato da un file
 In un sistema Unix tutte le risorse sono rappresentate da un file
c

Quale delle seguenti affermazioni sul comando kill è vera?
 È obbligatorio specificare il segnale da inviare, come numero intero
 Lanciato senza nessun argomento, manda SIGKILL all’ultimo processo lanciato
 Può essere usato per ottenere lo stesso risultato tanto del CTRL+C quanto del CTRL+Z
 Nessuna delle altre affermazioni è vera
c

Quale delle seguenti affermazioni sui processi Linux è vera?
 Ogni processo è identificato da un PID e da un job id, che devono coincidere
 Un job è un comando della bash che prende sempre il controllo dello stdin
 Nessuna delle altre opzioni è vera
 Fissato un istante nell’esecuzione del sistema operativo, ci sarà sempre al massimo un job in foreground, mentre quelli in background possono essere più d’uno
d

Si supponga che sia appena stata eseguita la seguente riga di codice di un processo: int pid = fork();. Quale delle seguenti affermazioni è vera?
 Nel processo padre, la variabile pid vale assume 1 solo valore, corrispondente al suo stesso PID
 Nel processo figlio, la variabile pid vale assume 1 solo valore, corrispondente al PID del padre
 C’è un nuovo processo pronto per andare in esecuzione, a meno che la variabile pid non valga -1
 Nel processo padre, la variabile pid assume 2 diversi valori
c

Quali delle seguenti affermazioni sulla variabile IFS è vera?
 Può essere usato per cambiare l’esecuzione di un ciclo for della bash
 Contiene il carattere utilizzato per la separazione in token da awk
 Nessuna delle opzioni è vera
 Deve contenere, come valore, un solo carattere, da usare per la separazione in parole nella bash (word splitting)
a

Quale delle seguenti affermazioni sui processi Linux è vera?
 Il processo control block mantiene le informazioni essenziali di ogni processo, è mantenuto su disco e viene swappato in RAM quando il processo va in esecuzione
 Lo heap contiene i dati statici inizializzati ed alcune costanti d’ambiente
 Il text segment contiene le istruzioni da eseguire, e viene sempre mantenuto interamente in RAM
 Nessuna delle altre opzioni è vera
d

Quale dei seguenti linguaggi non è mai stato usato per implementare Unix?
 L’assembler del PDP7
 Il B
 Il C
 Le altre risposte contengono tutte dei linguaggi usati per implementare Unix
d

Quale delle seguenti affermazioni sulle espressioni regolari è vera?
 Il metacarattere + consente di concatenare due regex
 Non è mai stato possibile definire un match con il carattere .
 Nessuna delle altre opzioni è vera
 Un carattere literal ha un match con se stesso
d

Quale delle seguenti affermazioni è vera?
 Il file system di Linux è una foresta ovvero un albero con più radici (una per ogni dispositivo fisico di memoria di massa collegato alla macchina, per esempio hard disk, chiave USB, CD, DVD, …)
 Nel file system di Linux, ogni nodo interno è un file o una directory, mentre le foglie sono sempre directory
 Nel file system di Linux esistono anche directory (denominate virtuali) che non si trovano su nessun dispositivo fisico di memoria di massa
 Il file System di Linux è gerarchico, perché per accedere ad un file occorre effettuare una chiamata di sistema al kernel
c

Quale delle seguenti affermazioni sul comando find è falsa?
 È possibile restringere la ricerca ai soli file che sono link simbolici
 È obbligatorio che gli starting point siano delle directory
 È possibile cercare nomi di file che rispettino un dato pattern o una data regular expression
 È possibile cercare anche directory, e non solo file
b

Quale delle seguenti affermazioni sul filesystem Linux è vera?
 Tutte le opzioni sono false
 È logicamente unico ed ha come punto di inizio la root (radice) rappresentata dal simbolo /
 Tutte le opzioni sono vere
 È una struttura ad albero in cui le directory sono nodi intermedi e non possono mai essere nodi terminali
b

Quale delle seguenti affermazioni è vera?
 Non è possibile definire una basic REGEX che abbia un match con una stringa formata da 3 o più occorrenze del carattere *
 Il metacarattere ^ consente di dichiarare un match ad inizio stringa solo se compare come primo carattere della REGEX
 @ è un metacarattere delle REGEX estese
 Tutte le risposte sono vere
b

Quale delle seguenti affermazioni sui comandi cat e od è falsa?
 L’opzione -A di od permette di scegliere la base (decimale, ottale od esadecimale) di tutti i bytes da stampare
 L’opzione -n di cat fa precedere ogni riga stampata con il numero della riga stessa (a partire da 1)
 L’opzione -E di cat stampa anche il carattere $ alla fine di ogni riga
 L’opzione -j B di od permette di cominciare la visualizzazione a partire dal (B + 1)-esimo byte
a

Quale delle seguenti affermazioni è falsa?
 Il carattere \ ha un match con la regex ‘\’
 . è un metacarattere che ha un match con una occorrenza di qualsiasi carattere
 I mecataratteri [] consentono di definire il match con un range di caratteri
 La concatenazione di due o più regex è una regex
a

Il linguaggio C:
 Viene definito per la creazione del primo Sistema Operativo Unix
 Nasce negli anni 70 per sviluppare programmi portabili su diverse architetture hardware
 Nasce come linguaggio di programmazione proprietario per l’implementazione dei programmi sui sistemi DEC PDP-11
 Nasce negli anni 70 come evoluzione del linguaggio B
d

Esiste in unix un comando che consente di stampare il numero di occorrenze di una riga di un file?
 Nessuna delle altre opzioni è ver
 No, occorre utilizzare congiuntamente i comandi uniq e wc
 No, occorre utilizzare congiuntamente i comandi sort e wc
 Si
d

Quali tra le seguenti affermazioni è vera?
 cat -N -6 filename stampa le ultime 6 ighe del filename
 tail -c n filename stampa le ultime n righe del filename
 cut consente di tagliare un file in gruppi di righe contigue in base a un carattere di spaziatura
 nessuna delle altre risposte è vera
d

Quale delle seguenti affermazioni sulle applicazioni client-server realizzate tramite socket è vera?
 Il client deve sempre chiamare la syscall bin
 Il server deve chiamare la syscall connect
 Il client deve sempre chiamare la syscall listen
 Sia il server che il client devono sempre chiamare la syscall socket
d

Si supponga di voler scrivere un programma immune al CTRL+C. Quali dei seguenti frammenti di codice realizza quanto detto sopra?
 signl( SIGTERM, SIG_DFL);
 signal( SIGINT, SIG_DFL);
 signal(SIGINT, SIG_IGN);
 Non è possibile essere immuni al CTRL+C
c
